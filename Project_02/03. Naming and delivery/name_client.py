#!/usr/bin/env python3#   Assignment : CPSC-551 Project_02#   Authors    : Rahul Chauhan        (rahulchauhan@csu.fullerton.edu)#                Harshit Singh Rathod (rathod10892@csu.fullerton.edu)#   Program    : Naming clientimport proxyimport configimport codeimport shleximport sysfrom sys import stderr# class to get the command from command line and decide whether it is a actual command or notclass CommandRunner(object):    def __init__(self):        self.commands = {}    def command(self, name, fn):        self.commands[name] = fn    def run(self, line):        tokens = shlex.split(line, comments=True)        command, args = tokens[0], tokens[1:]        if command not in self.commands:            print('{}: no such command'.format(command), file=stderr)            return        result = self.commands[command](*args)        if result is not None:            print(result)# class to create the consoleclass Console(object):    ps1 = '> '    ps2 = '. '    def __init__(self, runner):        self.runner = runner    def run(self, fd):        for line in fd:            self.runner.run(line)    def interact(self, locals=None):        class LambdaConsole(code.InteractiveConsole):            def runsource(code_console, source, filename=None, symbol=None):                # Return True if more input needed, else False.                try:                    self.runner.run(source)                except SystemExit:                    raise                except:                    code_console.showtraceback()                return False        # import readline to support line editing within console session.        try:            import readline; readline        except ImportError:            pass        # Patch ps1 & ps2 for interaction.        ps1, ps2 = getattr(sys, 'ps1', None), getattr(sys, 'ps2', None)        try:            sys.ps1, sys.ps2 = self.ps1, self.ps2            LambdaConsole(locals=locals, filename="<demo>").interact(banner='Start typing the message. Accepted template(s) "blog._out [content]"')        finally:            sys.ps1, sys.ps2 = ps1, ps2    def run_in_main(self, fd=None, interact=False):        if fd is None:            fd = sys.stdin        if fd.isatty():            self.interact()        else:            try:                self.run(fd=fd)            except Exception as err:                print(err, file=stderr)                return 1        return 0# class to handle delivery of the message to all users# connect to naming ts and give a nonblocking call to get list of users# for each user get the adapter_uri and deliver the message# if no users found then return "No active users"# if a ts is down then skip to next userclass Blog(object):    def __init__(self):        self.users = set()    def write(self, content):            content = content[1:-1]            content = list(map(str,content.split(',', 2)))            ts = proxy.TupleSpaceAdapter('http://localhost:8004')            try:                users = ts._rdp(["users", None])[1]            except:                users = []                print("No active users")            for i in range(0,len(users)):                user_adapter = ts._rdp([users[i], None])[1]                blog = proxy.TupleSpaceAdapter(user_adapter)                try:                    blog._out(content)                except:                    print("Skipping to next user." f'{users[i]}' " not active")def main(fd=None):    blog = Blog()    runner = CommandRunner()    runner.command('blog._out', blog.write)    return Console(runner).run_in_main(fd)if __name__ == '__main__':    sys.exit(main())